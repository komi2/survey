# ガベージコレクションの基礎学習


## 1: Introduction
なぜ今回ガベージコレクション（GC）を学習することになったかというと元々筆者自身が計量プログラミング言語(LL *1)から入り、自分のプログラムが奥でどのように動いてるかが気になり始め言語処理系の学習を試みることにした所に始まる。言語処理系の学習においてGCのアルゴリズムの理解は必要不可欠であり役割、種類などを学習するうちにGC自体に興味を持ったのでサーベイした概要を本稿に簡単にまとめた。  

学習目的としては今後言語処理系の開発に役立てようとすることが第一の目的である。上位レイヤーでの（本来メモリーを意識しないような）開発においてのクオリティ向上も狙いの一つである。
例えば、今日のモバイルWebアプリケーションやサービスは数年前と比べ驚くほどリッチでありインタラクティブな表現が当たり前になっている。
そういった中ブラウザが落ちることはさほど珍しいことではない。もちろんGCを理解したところでそれが解決出来るかは別として、問題解決の糸口にはなると考えられる。
問題解決だけでなくブラウザの限界に挑戦する上でも知識は必要であり、今後LL言語利用者がC言語系でのソフトウェア開発やモバイルアプリケーション開発に移行する際にも基礎概念理解は大きなアドバンテージになると思われる部分にも今回の学習目的がある。  

またGCの理解をより深めることによってJavaで運用されている既存システムのVM (Hot Spot VMなど)チューニングを行えるようにもなるし、Webアプリケーション開発においてもJavaScript実行エンジン(V8など)の挙動をイメージしながら描いたコードと無知のまま描いたコードでは意識の違いからコードの質に差が出てくるとであろうと考えられる。ここでいうコードの質とは如何に要件、環境に最適化されたコードであるかという点である。

筆者の浅い経験からの邪推になってしまうが、LLしか経験がないプログラマ(筆者を含む)の多くがGCをただ「自動でメモリを解放してくれるモノ」と抽象的(ブラックボックス)に考えているように思われる。GCと言えど種類は数多く存在するが本稿では基本的なアルゴリズムを学習する。


> *1 Lightweight Language: Perl, Python, PHP, Rubyなどのスクリプト言語のこと。

## 2: The basic principle of Garbage Collection
### 2.1 そもそもGCとはなにか
C/C++などのプログラマにとっては当たり前のことかもしれないが、通常オブジェクトやデータはメモリに割り当て必要でなくなったら自前で解放しなくてはならない。JavaやPythonその他言語ではこういった作業はプログラマ本人は行わないが実際はメモリにデータが割り当てられ、解放され...というようなルーチンが裏で働いている。  
本来メモリ管理にはアロケーターとガベージコレクターに分類されるが従来Garbage Collectionという言葉にこの2つの意味合いが含まれる。こういった割り当てた後、"__必要でなくなった__"オブジェクト（ゴミ = garbage）を解放（収集 = collection）してくれる__機構__のことをガベージコレクションと呼ぶ。  
ここで重要なのは__機構そのものをGCと呼び__その仕組みは様々な種類がある。  

### 2.2 GCの必要性 
そもそもGCがない環境とは以下の状況であると推測される。
  
 - メモリ解放ミス
  1. 解放タイミングのミスによる気づきにくいバグの生産
  -  ダングリングポインタ(*2)の生成
  - 使用中のメモリ領域の解放など

探せばまだあるかもしれないが 不要になった領域についてプログラマは全てを把握し解放しなければならない。小規模ならまだ管理できるかもしれないが、手動の場合ソフトウェアが複雑化すればするほどこういったヒューマンエラーは起きやすいと想像できる(*3)。

以上のことからGCを実装する必要性が感じられる。  デメリットをあげるとするとGCのアルゴリズムによってはフラグメンテーションが起きやすかったりGCの処理が走ることによりプログラム自体が停止することがある。  
開発者が技術選定を行う際には要件などと照らし合わせるためにGCのアルゴリズムの理解が必須と言える。

> *2  オブジェクトは破棄されているがポインタの初期化忘れによる不正なメモリ領域を指している状態。  
*3 Boehm GCやBoostのsmart_ptrと言ったようなGCライブラリも存在する。

## 3:  Basic algorithm

### 3.1 基本的なアルゴリズム
GCのアルゴリズムは大きく分けて以下に分類される。  
 1. Reference Counting
 2. Tracing GC

GCのアルゴリズムは数多く存在するが大きくこの2つに分類され、多数あるGCは基本的にこれらの複合や応用的な派生系に相当する。本稿では以下の3つに焦点を絞って学習する。

* Reference Counting
* Mark & Sweep
* Copying GC

### 3.2 評価項目
GCについてサーベイした中で個人的に以下の結論に至った。  
それは「__全ての要件を満たすような完璧なアルゴリズムはない__」ということである。  
そもそもGCは1960年前後に_John McCarthy_(*4)によって発案され、既に50年以上もの研究がされている非常に枯れた技術である。それにも関わらず未だに完璧なアルゴリズムがないという技術者にとっては非常にロマンがある分野でもある。ではいったい数多くあるアルゴリズムの中からどれを選べばいいのだろうか。それは以下の評価項目を基準にして選ぶのが妥当と言われる。

 1. スループット
 - リアルタイム性
 - ヒープ領域の使用効率
 
#### 3.2.1 スループット
プログラムのランタイム全体の中でのGCに浪費される時間の比。当然スループットが高ければ高い程良い。  
この場合のスループットとは__解放した領域の大きさ / 解放のために費やした時間__である。

#### 3.2.2 リアルタイム性
一般的にスクリプト言語やゲーム、ロボット等の分野ではリアルタイム性が重視され、スループットとリアルタイム性はトレードオフの関係にある。一昔前のJavaなどではアプリケーションが起動中に数秒停止（Stop-the-world）するといったようなことが起きていたようであり、スループットを求めた結果がこれに当たる。

#### 3.2.3 ヒープ領域の使用効率
リソースなどの実行環境に制限がある場合はヒープ領域の枯渇を気にしなければいけない。
次章でも記述するがCopying GCではヒープ領域を二分割にして利用しなければならない。潤沢なヒープ領域があればいいのだが、少ない場合はそれも考慮する必要がある。使用効率も同様にスループット、リアルタイム性とトレードオフの関係にある。

> *4 人工知能の第一人者でありプログラミング言語LISPの生みの親。

## 4: Types of Garbage Collection


### 4.1 Mark & Sweep
MarkフェーズとSweepフェーズで構成されるアルゴリズムである。
Markフェーズではルートから辿ることの出来るオブジェクトを再帰的に全てマークし（オブジェクトのヘッダに1ビットのマークビットを割り当てるのが一般的）、このマーキングサイクルの後Sweepフェーズではヒープ全体をスキャンしてマークのついてないオブジェクトを一掃する。これが基本的なアルゴリズムである。アロケーションが出来なくなった時点を起動のフックとする。

#### 4.1.1 メリット
* アルゴリズムがシンプルである。

#### 4.1.2  デメリット
* フラグメンテーションが起きやすい。
* アロケーションの速度が遅くなりがちである。

### 4.2 Reference Counting
オブジェクトのヘッダ情報として整数の値を与え、その値が0になったところでそのオブジェクトの破棄をする。具体的にはオブジェクトが生成された時点で1を付加し、ポインタがオブジェクトを指し示すたびにこの値はインクリメントされ参照が切れた時点でその値はデクリメントが行われる。この考え方はObjective-CのARCとしても利用されている。

#### 4.2.1 メリット
* リアルタイム性が高い。　

#### 4.2.2  デメリット
* 参照数のカウントアップやカウントダウンの際に毎度余分なオーバーヘッドがかかる。
* aがbのポインタを指し、bがaのポインタを指すような循環参照の回収がいつになっても出来ない。

### 4.3 Copying GC
ヒープ領域をそれぞれコピー元の **"from space"** とコピー先の **"to space"** に２分割する。  
アロケーションはfrom spaceを利用して行い、from spaceがあふれたところでGCを起動する。  
from spaceの生きたオブジェクトのみをto spaceへ隙間無くつめてコピーし、コピーが完了したところでfrom spaceを全て一掃しfrom space と to spaceを入れ替えてGCを終了する。

#### 4.3.1 メリット
* フラグメンテーションが起きない。
* フリーリストを使用しないためアロケーションが高速である。

#### 4.3.2  デメリット
* ヒープ領域の使用効率が悪い。

### 4.4 Tricolorマーキングの概念
Mark & Sweep や Copying GCなどのマーキングをするようなアルゴリズムでよく用いられる概念である。GC起動前は全てのオブジェクトは白色に分類され、GC起動後はオブジェクトはそれぞれ__白色、黒色、灰色の3種類の色__に分類される。

* 白色 - ルートからたどり着けないリサイクル候補のオブジェクト
* 黒色 - ルートからたどり着けたオブジェクト
* 灰色 - ルートからたどり着けたが白色を参照している可能性もある不明なオブジェクト。

詳しくは[こちら](http://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking)を参照


## 5: Conclusion

本稿ではベーシックな3種類のアルゴリズムを紹介したが、現在稼動しているようなプログラムなどはもっと複雑なアルゴリズムであることが多い。しかし基本的にこの3つの概念を元に作られていることが多いのでベースとなるアルゴリズムを熟知した上でより複雑なアルゴリズムの学習を続ける必要がある。  
